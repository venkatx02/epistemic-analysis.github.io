<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Venkat Dasari">
<meta name="dcterms.date" content="2025-02-26">

<title>Exploring the Corpus – Epistemic Analysis Project</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Epistemic Analysis Project</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Introduction</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../author.html"> 
<span class="menu-text">About Author</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Exploring the Corpus</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Venkat Dasari </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 26, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>I’ll start by reframing the research question… (They say good research questions start with “Why?”)</p>
<p><b> Research Question </b></p>
<p><b> Why do people make certain assertions? </b></p>
<p>The research question, “Why do people make certain assertions?” aims to explore and understand how individuals, groups, or societies think about, acquire, and justify knowledge, including their beliefs about the nature of knowledge, truth, and evidence—what we’ll call “epistemic patterns.” These patterns can be identified by analyzing modern digital discourse from spaces such as social media, customer reviews, or debates. For example, when someone on social media says, “Vaccines are essential because clinical trials show they work”, they’re using an empiricist pattern. They trust evidence and real-world observations. On the other hand, someone who says, “Freedom of speech matters because it’s a natural right”, follows a rationalist pattern. They rely on logical reasoning and principles they believe are naturally true. By studying these patterns, we can better understand how people reason, what influences their beliefs, and how they persuade others.</p>
<p>Epistemic patterns are basically the ways people back up their statements with reasons or evidence. These patterns reflect different beliefs people hold about knowledge, and they’re often grouped into pairs that represent opposite (or) partially opposite ways of thinking:</p>
<p>Empiricism and Rationalism: Empiricism means trusting what we can see, hear, or test through experience or experiments. Rationalism, on the other hand, means relying more on logical thinking or ideas that we think are naturally true, without needing proof from experience.</p>
<p>Foundationalism and Coherentism: Foundationalism believes knowledge should start from basic truths, things we consider obviously true, and build from there. Coherentism says knowledge is valid if our ideas consistently fit together, like pieces in a puzzle.</p>
<p>Internalism and Externalism: Internalism suggests knowledge depends mostly on what’s happening inside our minds, like our personal reasons or justifications. Externalism argues that knowledge also relies on outside facts or conditions we might not be fully aware of.</p>
<p>Skepticism and Fallibilism: Skepticism questions whether we can ever truly know something for sure. Fallibilism agrees that absolute certainty is rare but adds that we can still trust our knowledge as long as we’re open to revising it when new evidence comes along.</p>
<p>While these pairs represent opposing or partially opposing viewpoints, real-world reasoning rarely fits neatly into one category. Instead, people’s beliefs and arguments usually fall somewhere along a spectrum, blending different proportions of these ideas.</p>
<p>For starters, this project is focused on identifying proportions of rationalism and empiricism, although all other schools of thought will be systematically included in future phases of research.</p>
<p>The initial goal of this project is to build a reliable classifier that can identify the proportions of rationalism and empiricism in modern texts. Inspired by the Philosophy Data project (<a href="https://philosophydata.com/" class="uri">https://philosophydata.com/</a>), which focuses broadly on identifying philosophical tendencies, our project is specifically interested in detecting epistemic tendencies and knowledge patterns. To achieve this, we’ll use transformer-based language models like BERT and RoBERTa. We might also experiment with GPT models, although they’re not primarily designed for classification tasks. These models are pre-trained on large-scale text data, and we’ll further fine-tune them on carefully annotated examples of rationalist and empiricist language to improve their accuracy and performance for our specific classification task.</p>
<p>The classification and/or detection of epistemological tendencies in discourse using language models holds significant practical potential. For example, in politics, identifying how people reason helps analysts understand what’s behind different policies or voting behaviors. In business, knowing people’s reasoning styles can help predict how consumers make decisions or how they’ll respond to marketing. In education, recognizing student’s reasoning patterns can guide teachers in designing better lessons to develop critical thinking and evidence-assessment skills. In journalism and media, spotting these patterns can help identify misinformation or persuasive techniques, which leads to clearer and more informed public discussions.</p>
<p><b>The Corpus</b></p>
<p>To explore this research question, an initial corpus has been compiled using texts that explicitly discuss rationalism and empiricism. As a starting point, I’m using the corpus from the Philosophy Data Project (credits: <a href="https://philosophydata.com/bibliography.html" class="uri">https://philosophydata.com/bibliography.html</a>), which includes works by key rationalist and empiricist philosophers. These texts are freely accessible through Project Gutenberg. Thanks to both Philosophy Data Project and Project Gutenberg for making my life easier :)</p>
<p><b>Books discussing Empiricism:</b></p>
<p>Berkeley, George. A Treatise Concerning the Principles of Human Knowledge. 2009. Project Gutenberg, www.gutenberg.org/ebooks/4723.</p>
<p>Berkeley, George. Three Dialogues between Hylas and Philonous in Opposition to Sceptics and Atheists. 2009. Project Gutenberg, www.gutenberg.org/ebooks/4724.</p>
<p>Hume, David. A Treatise of Human Nature. 2003. Project Gutenberg, www.gutenberg.org/ebooks/4705.</p>
<p>Hume, David. Dialogues Concerning Natural Religion. 2009. Project Gutenberg, www.gutenberg.org/ebooks/4583.</p>
<p>Locke, John. An Essay Concerning Human Understanding. 2004. Project Gutenberg, www.gutenberg.org/ebooks/10615. 2 vols.</p>
<p>Locke, John. Second Treatise of Government. 2010. Project Gutenberg, www.gutenberg.org/ebooks/7370.</p>
<p><b>Books discussing Rationalism:</b></p>
<p>Descartes, René. A Discourse on Method. Translated by John Veitch. 2008. Project Gutenberg, www.gutenberg.org/ebooks/59.</p>
<p>Descartes, René. Meditations on First Philosophy. Translated by Michael Moriarty, Oxford University Press, 2008.</p>
<p>Leibniz, G.W.. Theodicy: Essays on the Goodness of God, the Freedom of Man, and the Origin of Evil. Translated by E.M. Huggard. 2005. Project Gutenberg, www.gutenberg.org/ebooks/17147.</p>
<p>Malebranche, Nicolas. The Search After Truth. Edited by Thomas M. Lennon and Paul J. Olscamp, Cambridge University Press, 1997.</p>
<p>Spinoza, Benedict de. Ethics. Translated by R.H.M. Elwes. 2003. Project Gutenberg, www.gutenberg.org/ebooks/3800.</p>
<p>Spinoza, Benedict de. On the Improvement of the Understanding. Translated by R.H.M. Elwes. 1997. Project Gutenberg, www.gutenberg.org/ebooks/1016.</p>
<p>However, there’s an important consideration: the linguistic patterns in these historical texts may differ significantly from those used in modern discourse. Some scholars argue that the way we communicate and reason today has evolved, raising questions about whether these older texts can effectively represent modern epistemic tendencies. A couple of ideas I currently have are:</p>
<p>Using the current texts to build an initial model for labeling modern texts, then refining the results through human supervision.</p>
<p>Expanding the corpus with texts from PhilPapers, a comprehensive index and bibliography of philosophy, which covers philosophical concepts across various contexts and domains.</p>
<p><b>Corpus Summary</b></p>
<p>I have titled the file names starting with “E” for the empiricist texts and “R” for the rationalist texts. A summary of the corpus can be found in the image below:</p>
<p><img src="../images/corpus-summary.png" width="600" style="display: block; margin: auto;"></p>
<p>The empiricist texts, Hume’s “A Treatise of Human Nature” (E3) and Locke’s “An Essay Concerning Human Understanding” (E5), and the rationalist texts, Leibniz’s “Theodicy” (R2) and Descartes’s “Meditations on First Philosophy” (R5) are significantly longer in their respective corpora with a word count of more than 170000.</p>
<p>Leibniz’s “Theodicy” has a huge vocabulary size of 13,006 unique words, indicating a highly diverse lexicon and possibly complex conceptual content. Hume’s “A Treatise of Human Nature”, Descartes’s “Meditations on First Philosophy” and Locke’s “An Essay Concerning Human Understanding” also have a considerable vocabulary.</p>
<p>Empiricist texts generally range around 30-40 words per sentence, whereas rationalist texts show more variation, some with extremely long sentences (Descartes) and some shorter (Spinoza’s “Ethics”).</p>
<p><b>Corpus Readability</b></p>
<p><img src="../images/corpora-readability-scores.png" alt="readability-scores" width="700" style="display: block; margin: auto;"></p>
<p>Rationalist texts tend to be a bit easier to read. Empiricist texts are somewhat harder, meaning they’re probably denser or use more complex explanations. I believe these differences suggest that rationalist and empiricist authors write differently.</p>
<p>Generally, a Flesch reading ease score between 60 and 70 and a Flesch-Kincaid grade level of 8 are considered ideal for most content. However, our corpus does not fall into these benchmarks.</p>
<p><b>Book-wise Word Frequencies</b></p>
<p><img src="../images/empiricism-book-wise-word-frequency.png" alt="empiricism-book-wise-word-frequency" width="800" style="display: block; margin: auto;"></p>
<p><img src="../images/rationalism-book-wise-word-frequency.png" alt="rationalism-book-wise-word-frequency" width="800" style="display: block; margin: auto;"></p>
<p>In the empiricist texts, unique words like “sense”, “perceived”, “experience”, and “objects” highlight their focus on sensory evidence and observation. Rationalist texts use distinct words such as “certain”, “truth”, “reason” and references to “god” reflecting their emphasis on logical certainty and innate truths. These unique words clearly show the differences in how each group thinks about and justifies knowledge. However, both corpora share some common high-frequency words, such as “one”, “idea” and “mind”. What do you think about this overlap?</p>
<p><b>Word Frequency</b></p>
<p><img src="../images/corpora-word-frequency.png" alt="corpora-word-frequency" width="800" style="display: block; margin: auto;"></p>
<p>The above bar graphs show the frequency of the top 10 words from both corpora rather than book-wise word frequencies. I think the book-wise word frequencies gave us more insights about similarities within corpora and distinction between empiricist and rationalist texts.</p>
<p><b>Word Cloud</b></p>
<p><img src="../images/corpora-word-cloud.png" alt="word-cloud" width="800" style="display: block; margin: auto;"></p>
<p>The word clouds allow us to examine the top 200 words in both the empiricism and rationalism corpora. So, what do you think?</p>
<p><b>Bigram Frequency</b></p>
<p><img src="../images/corpora-bigram-frequency.png" alt="corpora-bigram-frequency" width="800" style="display: block; margin: auto;"></p>
<p>Common pairs in the empiricism corpus include “simple ideas”, “every one”, “one another”, and “cause effect”. Frequent pairs in the rationalist texts are “objections replies”, “human body”, “human mind”, “idea god” and “clearly distinctly”. Although there are no identical pairs found in both corpora, Is there a linguistic distinction?</p>
<p>(I’m probably going to need help from a linguistics major for this one!)</p>
<p><b>Trigram Frequency</b></p>
<p><img src="../images/corpora-trigram-frequency.png" alt="corpora-trigram-frequency" width="800" style="display: block; margin: auto;"></p>
<p>Again, there are no identical trigrams found in both corpora. However, interpreting these trigrams as meaningful phrases is tricky since stop words were removed. I tried analyzing without removing stop words, but then most trigrams ended up containing only stop words. Let me know what you think!</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="quarto-dev/quarto-web" issue-term="title" theme="github-dark" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->




</body></html>